/** @file paex_pink.c
	@ingroup examples_src
	@brief Generate Pink Noise using Gardner method.

	Optimization suggested by James McCartney uses a tree
	to select which random value to replace.
  <pre>
	x x x x x x x x x x x x x x x x
	x   x   x   x   x   x   x   x
	x       x       x       x
	 x               x
	   x
  </pre>
	Tree is generated by counting trailing zeros in an increasing index.
	When the index is zero, no random number is selected.

	@author Phil Burk  http://www.softsynth.com
*/
/*
   $Id$

   This program uses the PortAudio Portable Audio Library.
   For more information see: http://www.portaudio.com
   Copyright (c) 1999-2000 Ross Bencina and Phil Burk

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files
   (the "Software"), to deal in the Software without restriction,
   including without limitation the rights to use, copy, modify, merge,
   publish, distribute, sublicense, and/or sell copies of the Software,
   and to permit persons to whom the Software is furnished to do so,
   subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
   ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
   CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*
   The text above constitutes the entire PortAudio license; however,
   the PortAudio community also makes the following non-binding requests:

   Any person wishing to distribute modifications to the Software is
   requested to send the modifications to the original developer so that
   they can be incorporated into the canonical version. It is also
   requested that these non-binding requests be included along with the
   license above.
*/

#include <math.h>
#include <Arduino.h>
#include <driver/adc.h>


#define PINK_MAX_RANDOM_ROWS   (30)
#define PINK_RANDOM_BITS       (24)
#define PINK_RANDOM_SHIFT      ((sizeof(long)*8)-PINK_RANDOM_BITS)


//  Created by bobolink
//  twitter: @wm6h
//  rev: 20180310

/*
   Two core ESP-32 Arduino real-time audio demo.
   Tested on Espressif ESP32 Dev board
   Rev. 1 silicon
   Real-Time Samples at 8Ksps for voice audio range (< 4KHz).
   Not for music.
   Compatible with Arduino IDE

   pink noise
*/


int LED_BUILTIN = 5;

const uint16_t  N = 1024; // should be a power of 2 for FFTs
// Determines how long the Application Processor can run for
// real-time applications
// or how long the Application has to write the samples to
// a ring buffer for non-real time applications.
// Latency, analog input to output, is a function of N.

// we create complex numbers here for convenience
// could be done in frame processing
volatile double realPing[N];
volatile double imagPing[N];
volatile double realPong[N];
volatile double imagPong[N];

// Do frame processing in floats for better dynamic range.
// At last stage, scale floats to range -1.0 to +1.0
// then convert to unsigned char. Mult by 127 and
// adding 128 to map +1.0 -- -1.0 to 0-255 for
// output to 8-bit unsigned DAC

// we create analytic IQ input samples
// but we only output real numbers!
volatile unsigned char outRealPing[N];
volatile unsigned char outRealPong[N];


float volume = 1.0;
int   frameCNT = 0;

portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;

// this is Core 1's variable.
// Core 0 will operate on the other buffer
volatile boolean pingCore1 = true;

volatile boolean sampling = false;
volatile boolean outputEnable = true;

TaskHandle_t Task1;
SemaphoreHandle_t newFrame;

esp_err_t result;


void IRAM_ATTR onTimer()
{

  portENTER_CRITICAL_ISR(&timerMux);
  sampling = true;
  portEXIT_CRITICAL_ISR(&timerMux);

}


typedef struct
{
  long      pink_Rows[PINK_MAX_RANDOM_ROWS];
  long      pink_RunningSum;   /* Used to optimize summing of generators. */
  int       pink_Index;        /* Incremented each sample. */
  int       pink_IndexMask;    /* Index wrapped by ANDing with this mask. */
  float     pink_Scalar;       /* Used to scale within range of -1.0 to +1.0 */
}
PinkNoise;

/* Prototypes */
static unsigned long GenerateRandomNumber( void );
void InitializePinkNoise( PinkNoise *pink, int numRows );
float GeneratePinkNoise( PinkNoise *pink );


/*******************************************************************/
//#define PINK_TEST
//#ifdef PINK_TEST

/* Context for callback routine. */
typedef struct
{
  PinkNoise   leftPink;
  PinkNoise   rightPink;
  unsigned int sampsToGo;
} paTestData;

// should be shifting more to the heap
paTestData *data = (paTestData*)malloc(sizeof(paTestData));  



#define PINK_MEASURE
#ifdef PINK_MEASURE
float pinkMax = -999.0;
float pinkMin =  999.0;
#endif

void setup()
{
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);

  Serial.begin(115200);

  newFrame = xSemaphoreCreateMutex();


  xTaskCreatePinnedToCore(
    frameProcessing,
    "FrameProcessing",
    700,
    NULL,
    1,
    &Task1,
    0);

  delay(500);  // needed to start-up task1


  // zero the DAC buffers
  for (int i = 0; i < N; ++i)
  {
    outRealPing[i] = 0;
    outRealPong[i] = 0;

  }

  // this almost matches the output resolution
  // all channels  are GPIOs 32-39
  result = adc1_config_width(ADC_WIDTH_9Bit);
  // complete with Apple type error message
  if (result != ESP_OK)
  {
    Serial.println("Error, an unknown error occurred");
  }

  // this might allow 3.3VDC on the mic
  // pin 34
  result = adc1_config_channel_atten( ADC1_CHANNEL_6, ADC_ATTEN_11db);
  if (result != ESP_OK)
  {
    Serial.println("Error, an unknown error occurred");
  }

  Serial.print("Setup: Executing on core ");
  Serial.println(xPortGetCoreID());

  //data = &userData;

  /* Initialize two pink noise signals with different numbers of rows. */
  // InitializePinkNoise( &data->leftPink,  12 );
  InitializePinkNoise( &data->rightPink, 16 );

  hw_timer_t* timer = timerBegin(0, 80, true);
  timerAttachInterrupt(timer, &onTimer, true);
  timerAlarmWrite(timer, 125, true); // sampling frequency 8kHz
  timerAlarmEnable(timer);

}


// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// Core1Core1Core1Core1Core1Core1Core1Core1Core1Core1Core1Core1
//                   This Task runs on Core: 1
// Core1Core1Core1Core1Core1Core1Core1Core1Core1Core1Core1Core1
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

// ||||||||||||||||||
//  Sample Service
// ||||||||||||||||||
void loop()
{
  for (int i = 0; i < N; ++i)
  {
    while (!sampling);

    portENTER_CRITICAL(&timerMux);
    sampling = false;
    portEXIT_CRITICAL(&timerMux);

    //digitalWrite(LED_BUILTIN, HIGH);
    if (pingCore1 == true)
    {
      // configured for 9 bits with an 11 dB pad
      // drop one bit to give 8 to match the output
      realPing[i] = (float) (((byte)((adc1_get_voltage(ADC1_CHANNEL_6) >> 1) & 0xFF)) - 128.0);
      imagPing[i] = 0.0;
      // DAC output is 8-bit unsigned. Maximum (255) corresponds
      // for VDD_A 3.3V, to 2.59V
      if (outputEnable == true)
      { // GPIO pin 25 of the ESP32.
        // This is the output of DAC1
        dacWrite(25, outRealPing[i]);
      }
    }
    else
    {
      // drop one bit to give 8 to match the output
      realPong[i] = (float) (((byte)((adc1_get_voltage(ADC1_CHANNEL_6) >> 1) & 0xFF)) - 128.0);
      imagPong[i] = 0.0;
      // DAC output is 8-bit unsigned. Maximum (255) corresponds
      // for VDD_A 3.3V, to 2.59V
      if (outputEnable == true)
      { // for VDD_A 3.3V, to 2.59V
        dacWrite(25, outRealPong[i]);
      }
    } // end single sample processing
    //digitalWrite(LED_BUILTIN, LOW);
  } // end N samples processing

  // swap working buffer
  pingCore1 = !pingCore1;
  // give the old buffer to frame processing
  xSemaphoreGive(newFrame);
} // end sample service task

// /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
// 1111111111111111111111111111111111111111111111111111111111111
// /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


/*******************************************************************/

// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// Core0Core0Core0Core0Core0Core0Core0Core0Core0Core0Core0Core0
//                    This Task runs on Core: 0
// Core0Core0Core0Core0Core0Core0Core0Core0Core0Core0Core0Core0
// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
// Frame processing
// Runs every N samples

void frameProcessing( void* parameter )
{
  Serial.print("Frame Processing: Executing on core ");
  Serial.println(xPortGetCoreID());

  Serial.println(sizeof(*data));

  for (;;) // this is required, normally put in by
  { // Arduino IDE

    float outVal;
    //float pink[N];
    //float pink1[N];
    float pink;
    
    int    lm;

    frameCNT++;

    outputEnable = true;

    // "Arf! Arf!"
    // pet the watchdog.
    vTaskDelay(10);

    // wait for the ping-pong buffer swap
    // indicating frame processing should begin
    // Core 1 has the timer resolution and is in charge of buffers
    xSemaphoreTake(newFrame, portMAX_DELAY);

    digitalWrite(LED_BUILTIN, HIGH);
/*
    if ( (frameCNT % 2) == 0)
    {
     for (int j = 0; j < N; j++)
     {
       pink[j] = GeneratePinkNoise( &data->rightPink );
       pink1[j] = GeneratePinkNoise( &data->rightPink );
     }
    }
*/
    
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    // ++++++++++++++++++++++++++++++++++++++++++++++++++++
    // frame processing takes place here:
    for (int i = 0; i < N; ++i)
    {
      // NOTE:
      // this variable belongs to core 1 -- use the other buffer
      // If core 1 is ping, we are pong
      if (pingCore1 == true)
      {
        //outVal = 0;
        outVal = GeneratePinkNoise( &data->rightPink );
        outRealPong[i] = (unsigned char) (outVal * 127.0 + 128.0);
      }
      else
      {
        //outVal = 0;
        outVal = GeneratePinkNoise( &data->rightPink );
        outRealPing[i] = (unsigned char) (outVal * 127.0 + 128.0);
      }
    }// end frame processing of N samples

    digitalWrite(LED_BUILTIN, LOW);

  } // end Arduino task loop
}


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// This code ported from http://portaudio.com


/* Generate Pink noise values between -1.0 and +1.0 */
float GeneratePinkNoise( PinkNoise *pink )
{
  long newRandom;
  long sum;
  float output;


  // Increment and mask index.
  pink->pink_Index = (pink->pink_Index + 1) & pink->pink_IndexMask;
  // If index is zero, don't update any random values.

  if ( pink->pink_Index != 0 )
  {
    // Determine how many trailing zeros in PinkIndex.
    // This algorithm will hang if n==0 so test first.
    int numZeros = 0;
    int n = pink->pink_Index;

    while ( (n & 1) == 0 )
    {
      n = n >> 1;
      numZeros++;
    }

    // Replace the indexed ROWS random value.
    // Subtract and add back to RunningSum instead of adding all the random
    // values together. Only one changes each time.

    pink->pink_RunningSum -= pink->pink_Rows[numZeros];
    newRandom = ((long)GenerateRandomNumber()) >> PINK_RANDOM_SHIFT;
    pink->pink_RunningSum += newRandom;
    pink->pink_Rows[numZeros] = newRandom;


  }

  // Add extra white noise value.
  newRandom = ((long)GenerateRandomNumber()) >> PINK_RANDOM_SHIFT;
  sum = pink->pink_RunningSum + newRandom;
  // Scale to range of -1.0 to 0.9999.
  output = pink->pink_Scalar * sum;
#ifdef PINK_MEASURE
  // Check Min/Max
  if ( output > pinkMax ) pinkMax = output;
  else if ( output < pinkMin ) pinkMin = output;
#endif

  return output;
}

/************************************************************/
/* Calculate pseudo-random 32 bit number based on linear congruential method. */
static unsigned long GenerateRandomNumber( void )
{
  /* Change this seed for different random sequences. */
  static unsigned long randSeed = 22222;
  randSeed = (randSeed * 196314165) + 907633515;
  return randSeed;
}

/************************************************************/
/* Setup PinkNoise structure for N rows of generators. */
void InitializePinkNoise( PinkNoise *pink, int numRows )
{
  pink->pink_Index = 0;

  int i;
  long pmax;
  pink->pink_Index = 0;
  pink->pink_IndexMask = (1 << numRows) - 1;
  // Calculate maximum possible signed random value. Extra 1 for white noise always added.

  pmax = (numRows + 1) * (1 << (PINK_RANDOM_BITS - 1));
  pink->pink_Scalar = 1.0f / pmax;

  // Initialize rows.


  for ( i = 0; i < numRows; i++ )
  {
    pink->pink_Rows[i] = 0;
  }

  pink->pink_RunningSum = 0;


}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
// 0000000000000000000000000000000000000000000000000000000000000
// /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/



